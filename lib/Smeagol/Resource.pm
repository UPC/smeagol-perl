# Resource class definition
package Smeagol::Resource;

use strict;
use warnings;

use XML::LibXML;
use Smeagol::DataStore;
use Carp;
use Smeagol::XML;
use Data::Dumper;

use overload q{""} => \&toString;

# Create a new resource
sub new {
    my $class = shift;
    my ( $description, $agenda, $info, $tags ) = @_;

    # $agenda and $info arguments are not mandatory
    return if !defined $description;

    my $obj;

    # Load on runtime to get rid of cross-dependency between
    # both Resource and Agenda
    require Smeagol::Agenda;
    require Smeagol::TagSet;

    $obj = {
        id          => _getNextID(),
        description => $description,
        agenda      => ( defined $agenda ) ? $agenda : Smeagol::Agenda->new(),
        info        => ( defined $info ) ? $info : "",
        tags        => ( defined $tags ) ? $tags : Smeagol::TagSet->new(),
        _persistent => 0,
    };

    bless $obj, $class;
    return $obj;
}

# Setters and getters
sub id {
    my $self = shift;

    if (@_) { $self->{id} = shift; }

    return $self->{id};
}

sub description {
    my $self = shift;

    if (@_) { $self->{description} = shift; }

    return $self->{description};
}

sub agenda {
    my $self = shift;

    if (@_) { $self->{agenda} = shift; }

    return $self->{agenda};
}

sub info {
    my $self = shift;

    if (@_) { $self->{info} = shift; }

    return $self->{info};
}

sub url {
    my $self = shift;

    return "/resource/" . $self->id;
}

sub tags {
    my $self = shift;
    if (@_) { $self->{tags} = shift; }

    return $self->{tags};
}

# Constructor that fetchs a resource from datastore
# or fail if it cannot be found
sub load {
    my $class = shift;
    my ($id) = @_;

    return if ( !defined($id) );

    my $data = Smeagol::DataStore->load($id);

    return if ( !defined($data) );

    my $resource = Smeagol::Resource->newFromXML( $data, $id );

    return $resource;
}

# newFromXML: creates a Resource via an XML string
# If $id is defined, it will be used as the Resource ID.
# Otherwise, a new ID will be generated by DataStore
sub newFromXML {
    my $class = shift;
    my ( $xml, $id ) = @_;

    # Load on runtime to get rid of cross-dependency between
    # both Resource and Agenda
    require Smeagol::Agenda;
    require Smeagol::TagSet;

    # validate XML string against the DTD
    my $dtd = XML::LibXML::Dtd->new( "CPL UPC//Resource DTD v0.03",
        "dtd/resource.dtd" );

    my $dom = eval { XML::LibXML->new->parse_string($xml) };
    croak $@ if $@;

    if ( ( !defined $dom ) || !$dom->is_valid($dtd) ) {

        # validation failed
        return;
    }

    my $obj = {
        id => ( ( defined $id ) ? $id : _getNextID() ),
        description =>
            $dom->getElementsByTagName('description')->string_value,
        agenda      => Smeagol::Agenda->new(),
        info        => "",
        tags        => Smeagol::TagSet->new(),
        _persistent => 0,
    };

    if ( $dom->getElementsByTagName('agenda')->get_node(1) ) {
        $obj->{agenda} = Smeagol::Agenda->newFromXML(
            $dom->getElementsByTagName('agenda')->get_node(1)->toString );
    }

    my $info = $dom->findnodes('//resource/info')->get_node(1)->string_value;

    $obj->{info} = ( defined $info ) ? $info : "";

    if ( $dom->getElementsByTagName('tags')->get_node(1) ) {
        $obj->{tags} = Smeagol::TagSet->newFromXML(
            $dom->getElementsByTagName('tags')->get_node(1)->toString );
    }

    bless $obj, $class;
    return $obj;
}

sub toSmeagolXML {
    my $self        = shift;
    my $xlinkPrefix = shift;

    my $smeagolXML = eval { Smeagol::XML->new('<resource/>') };
    croak $@ if $@;
    my $dom = $smeagolXML->doc;

    my $resourceNode = $dom->documentElement;

    $resourceNode->appendTextChild( 'description', $self->{description} );

    if ( $self->{agenda}->size > 0 ) {
        my $agendaNode
            = $self->{agenda}->toSmeagolXML->doc->documentElement();
        $dom->adoptNode($agendaNode);
        $resourceNode->appendChild($agendaNode);
    }

    if ( $self->{info} ne "" ) {
        $resourceNode->appendTextChild( 'info', $self->{info} );
    }

    if ( $self->{tags}->size > 0 ) {
        my $tagSetNode = $self->{tags}->toDOM->documentElement();
        $dom->adoptNode($tagSetNode);
        $resourceNode->appendChild($tagSetNode);
    }

    if ( defined $xlinkPrefix ) {
        $dom->addXLink( "resource", $xlinkPrefix . $self->url );
    }

    return $dom;
}

sub toString {
    my $self = shift;
    my $url  = shift;

    my $dom = $self->toSmeagolXML($url);

    return $dom->toString;
}

sub toXML {
    return shift->toString(@_);
}

sub remove {
    my $self = shift;

    Smeagol::DataStore->remove( $self->{id} );
    $self->{_persistent} = 0;
}

# Save Resource in DataStore
sub save {
    my $self = shift;

    $self->{_persistent} = 1;
    Smeagol::DataStore->save( $self->{id}, $self->toXML() );
}

sub DESTROY {
    my $self = shift;

    $self->save if ( $self->{_persistent} );
}

sub _getNextID {
    return Smeagol::DataStore->getNextID(__PACKAGE__);
}

1;
